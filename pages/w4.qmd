---
title: "DBMS - Week 4"
format:
    html:    
        toc: true
        toc_depth: 2
        number_sections: true
        smooth-scroll: true
        code-fold: true
jupyter: python3
ipynb-shell-interactivity: all
---

# Formal Relational Query Language

- Relational Algebra
  - Procedural and Algebra based
- Tuple Relational Calculus
  - Non-Procedural (Declarative) and Predicate Calculus based
- Domain Relational Calculus
  - Non-Procedural (Declarative) and Predicate Calculus based

## Relational Algebra

- Relational algebra is a procedural query language which takes relations as input and returns relation as output.
- It was created by Edgar F. Codd at IBM in 1970.
- Six basic operators of relational algebra are:
  - Select ($\sigma$)
  - Project ($\Pi$)
  - Union ($\cup$)
  - Set Difference ($-$)
  - Cartesian Product ($\times$)
  - Rename ($\rho$)

## Select Operation

- Notation: $\sigma_{p}(r)$
- $p$ is called the *selection predicate*
- Definition:
  $$
  \sigma_{p}(r) = \{t \mid t \in r \text{ and } p(t) \}
  $$

  where $p$ is a formula in propositional calculus consisting  of terms connected by: $\land$ (**and**), $\lor$ (**or**), and $\lnot$ (**not**).

  Each *term* is one of:

  < *attribute* > op < *attribute* > or < *constant* >

  where op is one of: $=$, $\neq$, $<$, $\leq$, $>$, $\geq$

### Select Example

```{python}
import pandas as pd
from IPython.display import HTML
data1 = {
    'A': ['α', 'α', 'β', 'β'],
    'B': ['α', 'β', 'β', 'β'],
    'C': [1, 5, 12, 23],
    'D': [7, 7, 3, 10]
}

# Create DataFrame
df1 = pd.DataFrame(data1)

# Display the DataFrame without the index
HTML(df1.to_html(index=False))
# print(df1.to_string(index=False))
```

$$
r
$$

```{python}
# Selection operation: A = B and D > 5
selected_df_1 = df1[(df1['A'] == df1['B']) & (df1['D'] > 5)]

# Display the DataFrame without the index
HTML(selected_df_1.to_html(index=False))
```
$$
\sigma_{A=B\wedge D>5}(r)
$$

## Project Operation

- Notation: $\Pi_{A_1, A_2, \ldots, A_k}(r)$
  
  where $A_1, A_2, \ldots, A_k$ are attributes of relation $r$
- The result is defined as the relation of $k$ columns obtained by deleting columns other than $A_1, A_2, \ldots, A_k$ from $r$
- Duplicate rows are automatically eliminated, since the result is a set

### Project Example

```{python}
relation2 = {
    'A': ['α', 'α', 'β', 'β'],
    'B': [10, 20, 30, 40],
    'C': [1, 1, 1, 2]
}

# Create DataFrame
df2 = pd.DataFrame(relation2)

# Display the DataFrame without the index
HTML(df2.to_html(index=False))
```

$$
r
$$

```{python}
projected_df_1 = df2[['A', 'C']].drop_duplicates()

# Display the projected DataFrame without duplicates
HTML(projected_df_1.to_html(index=False))
```

$$
\Pi_{A, C}(r)
$$

## Union Operation

- Notation: $r \cup s$
- Defined as: $r \cup s = \{t \mid t \in r \text{ or } t \in s \}$
- For $r \cup s$ to be valid
  - $r$ and $s$ must have the same *arity* (same number of attributes)
  - The attribute domains must be *compatible* (same type)

### Union Example

```{python}
r = {
    'A': ['α', 'α', 'β'],
    'B': [1, 2, 1]
}

# Create DataFrame
df_r = pd.DataFrame(r)


s = {
    'A': ['α', 'β'],
    'B': [2, 3]
}

# Create DataFrame
df_s = pd.DataFrame(s)

# Display the DataFrame without the index
HTML(df_r.to_html(index=False))
```

$$
r
$$

```{python}
# Display the DataFrame without the index
HTML(df_s.to_html(index=False))
```

$$
s
$$

```{python}
# Union operation
union_df = pd.concat([df_r, df_s]).drop_duplicates()

# Display the DataFrame without the index
HTML(union_df.to_html(index=False))
```

<!-- ```{python}
import matplotlib.pyplot as plt

# initialize a figure
fig = plt.figure()
ax = fig.add_subplot(111)

# set the title
ax.set_title('Union Operation')

#create a table
ax.table(cellText=union_df.values, colLabels=union_df.columns, cellLoc = 'center', loc='center')

# hide the axes
ax.axis('off')
``` -->

$$
r \cup s
$$

## Difference Operation

- Notation: $r - s$
- Defined as: $r - s = \{t \mid t \in r \text{ and } t \notin s \}$
- Set differences must be taken between **compatible** relations
  - $r$ and $s$ must have the same *arity*
  - The attribute domains must be *compatible*

### Difference Example

```{python}
r = {
    'A': ['α', 'α', 'β'],
    'B': [1, 2, 1]
}

# Create DataFrame
df_r = pd.DataFrame(r)

s = {
    'A': ['α', 'β'],
    'B': [2, 3]
}

# Create DataFrame
df_s = pd.DataFrame(s)

# Display the DataFrame without the index
HTML(df_r.to_html(index=False))
```

$$
r
$$

```{python}
# Display the DataFrame without the index
HTML(df_s.to_html(index=False))
```

$$
s
$$

```{python}
# Difference operation
difference_df = df_r.merge(df_s, on=['A', 'B'], how='left', indicator=True).query('_merge == "left_only"').drop(columns=['_merge'])

# Display the set difference DataFrame without the index
display(HTML(difference_df.to_html(index=False)))
```

$$
r - s
$$


## Intersection Operation

- Notation: $r \cap s$
- Defined as: $r \cap s = \{t \mid t \in r \text{ and } t \in s \}$
- Assume:
  - $r$, $s$ have the same *arity*
  - Attributes of $r$ and $s$ are *compatible*
- Note: $r \cap s = r - (r - s)$

### Intersection Example

```{python}
import pandas as pd
from IPython.display import HTML

# Relation r
r = {
    'A': ['α', 'α', 'β'],
    'B': [1, 2, 1]
}

# Create DataFrame for r
df_r = pd.DataFrame(r)

# Relation s
s = {
    'A': ['α', 'β'],
    'B': [2, 3]
}

# Create DataFrame for s
df_s = pd.DataFrame(s)

# Display the DataFrame without the index
HTML(df_r.to_html(index=False))
```

$$
r
$$

```{python}
# Display the DataFrame without the index
HTML(df_s.to_html(index=False))
```

$$
s
$$

```{python}
# Intersection operation
intersection_df = pd.merge(df_r, df_s, on=['A', 'B'], how='inner')

# Display the intersection DataFrame without the index
display(HTML(intersection_df.to_html(index=False)))
```

$$
r \cap s
$$

## Cartesian-Product Operation

- Notation: $r \times s$
- Defined as: $r \times s = \{t_1, t_2 \mid t_1 \in r \text{ and } t_2 \in s \}$
- Assume that attributes of $r$ and $s$ are *disjoint* (no common attributes)
- If attributes are not disjoint, use *rename* operation to make them disjoint

### Cartesian-Product Example

```{python}
import pandas as pd
from IPython.display import HTML

# Relation r
r = {
    'A': ['α', 'β'],
    'B': [1, 2]
}

# Create DataFrame for r
df_r = pd.DataFrame(r)

# Relation s
s = {
    'C': ['α', 'β', 'β', 'γ'],
    'D': [10, 10, 20, 10],
    'E': ['a', 'a', 'b', 'b']
}

# Create DataFrame for s
df_s = pd.DataFrame(s)

# Display the original DataFrames without the index
display(HTML(df_r.to_html(index=False)))
```

$$
r
$$

```{python}
display(HTML(df_s.to_html(index=False)))
```

$$
s
$$

```{python}
# Cartesian product of df_r and df_s
cartesian_product_df = pd.merge(df_r.assign(key=1), df_s.assign(key=1), on='key').drop('key', axis=1)

# Display the Cartesian product DataFrame without the index
display(HTML(cartesian_product_df.to_html(index=False)))
```

$$
r \times s
$$

## Rename Operation

- Allows us to name, and therefore to refer to, the result of a relational-algebra expression
- Allows us to refer to a relation by more than one name
- Example:

  $\rho_{X}(E)$

  returns the relation $E$ under the name $X$
- If a relational-algebra expression $E$ has arity $n$, then
  $$
  \rho_{X(A_1, A_2, \ldots, A_n)}(E)
  $$
  returns the result of the expression $E$ under the name $X$, and with the attributes renamed to
  $$
  A_1, A_2, \ldots, A_n
  $$

### Rename Example

```{python}
import pandas as pd
from IPython.display import HTML

# Relation r
r = {
    'A': ['α', 'β'],
    'B': [1, 2]
}

# Create DataFrame for r
df_r = pd.DataFrame(r)

# Relation r's duplicate relation s
df_s = pd.DataFrame(r)

# Display the original DataFrame without the index
display(HTML(df_r.to_html(index=False)))
```

$$
r
$$

```{python}
# Cartesian product of df_r and df_s
cartesian_product_df = pd.merge(df_r.assign(key=1), df_s.assign(key=1), on='key').drop('key', axis=1)

# Rename the columns to make them unique
cartesian_product_df.columns = ['r.A', 'r.B', 's.A','s.B']

# Display the Cartesian product DataFrame without the index
display(HTML(cartesian_product_df.to_html(index=False)))
```

$$
r \times \rho_{s}(r)
$$


## Division Operation

- The division operation is applied to two relations
- $R(Z) \div S(X)$, where $X$ is a subset of $Z$. Let $Y = Z - X$ (hence $Z = X \cup Y$); that is, let $Y$ be the set of attributes of $R$ that are not in $S$
- The result of the division operation is a relation $T(Y)$ that includes a tuple $t$ if tuples $t_R$ appear in $R$ with $t_R[Y] = t$, and with
  - $t_R[X] = t_S$ for all tuples $t_S$ in $S$
- For a tuple $t$ to appear in the result $T$ of the division operation, the values in $t$ must appear in $R$ with all possible combinations of values in $S$
- Division is a derived operation, and can be expressed in terms of the basic operations of relational algebra
- $r \div s \equiv \Pi_{R - S}(r) - \Pi_{R - S}(r)((\Pi_{R - S}(r) \times s) - \Pi_{R-S,S}(r))$

### Division Examples

```{python}
import pandas as pd
from IPython.display import HTML
data1 = {
    'Lecturer': ['Brown', 'Brown', 'Green', 'Green', 'Lewis', 'Smith'],
    'Module': ['Compilers', 'Databases', 'Prolog', 'Databases', 'Prolog', 'Databases']
}

# Create DataFrame
df1 = pd.DataFrame(data1)

# Display the DataFrame without the index
HTML(df1.to_html(index=False))
```

$$
R
$$

```{python}
data2 = {
    'Subject': ['Prolog']
}

# Create DataFrame
df2 = pd.DataFrame(data2)

# Display the DataFrame without the index
HTML(df2.to_html(index=False))
```

$$
S
$$

```{python}
# Division operation
division_df = df1.groupby('Lecturer').Module.apply(set).reset_index()
division_df = division_df[division_df['Module'].apply(lambda x: df2['Subject'].values[0] in x)]
division_df = division_df.drop(columns='Module')

# Display the division DataFrame without the index
display(HTML(division_df.to_html(index=False)))
```

$$
R \mid S
$$

